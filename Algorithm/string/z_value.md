# Z algorithm
別稱：Z-value  
字串S[0:N-1]的Z-value  
Z[i]=( 最大的K滿足S[0:K-1]=S[i:i+k-1] )  
假設Z[i]值為n  
代表說S前n個字  
和S從i數過去n個字是一樣的  
比較特別的是：Z[i]=0(初始值設定)  
下面荔枝  
|i|0|1|2|3|4|5|6|7|8|  
|-|-|-|-|-|-|-|-|-|-|  
|S|a|b|a|a|b|a|a|b|b|
|Z|0|0|1|5|0|1|2|0|0|

## 觀察
算完Z[0]~Z[i-1]後，現在要計算Z[i]  
取任意一數l\<i  
已知S[0:Z[l]-1]=S[l:l+Z[l]-1]\(下方l範圍)  
如果l+Z[l]\>i  
代表位置l的Z-value覆蓋面積會壓到自己  
設p=i-l  
我們可得到S[p:Z[l]-1]=S[i:l+Z[l]-1]\(下方G的範圍)  
下面圖解  
|i|0|1|2|3|4|5|6|7|8|9|  
|-|-|-|-|-|-|-|-|-|-|-|  
|S|A|A|C|A|A|C|A|A|X|Y|  
|Z|0|1|0|5|?| | | | | |
|l|A|A|C|A|A| | | | | |  
|l| | | |A|A|C|A|A| | |  
|r| | | | | | | |r| | |
|i| | | | |i| | | | | |  
|p| | | | |V| | | | | |  
|G| |A|C|A|A| | | | | |  
|G| | | | |A|C|A|A| | |  
|p|A| | | | | | | | | |
|p| |A| | | | | | | | |
|i| | | | |A| | | | | |
有沒有發現一件事  
就是Z[i]的答案至少會是min(Z[i-l],r-i+1)  
(r代表目前檢查到哪裡)  
## 實作細節  
維護目前找到的最大右界r及相對應的左界l  
由小到大求出每個z[i]  
if i<=r，令p=i-l，則先把z[i]設成min(Z[i-l],r-i+1)  
開始暴力檢查，檢查S[i+z[i]]是否等於S[z[i]]\(嘗試擴增z[i]，因為剛剛只有說min...是至少，所以有機會擴增)  
if i+z[i]-1\>r update l=i,r=i+z[i]  
sample code(參考自 sprout)  
```c++
vector<INT> z_alg(string s){
	int n=s.size();
	int l=0,r=0;
	vector<int> z(n);
	for(INT i=1;i<n;i++){
		if(i<=r){
			z[i]=min(z[i-l],r-i+1);//z[i]的答案至少會是min(Z[i-l],r-i+1)，但如果i>r的話後項會變成負數
		}
		while(
			i+z[i]<n && //防止溢位
			s[z[i]]==s[i+z[i]] //確認字元是同樣的，可以加值
		){
			z[i]++;
		}
		if(i+z[i]-1>r){
			l=i,r=i+z[i]-1;
		}
	}
	return z;
}
```
