# KMP
給兩字串S,T(|S|<=|T|<=5e5)  
試問S在T中哪些位置出現  
爆搜？O(|S|\*|T|)  
顯然不可能
那我們能不能把已經跑過的地方,用特殊方式存起來  
答案是肯定  
先給例子
S=ababb aabab babaa
T=ababb aabab abbaa babba baa
|  |0  |1|2|3|4|5|6  |7|8|9  |.    |1|2|3|4|5|6|7|8|9|.|1|2|3|4|
|--|---|-|-|-|-|-|---|-|-|---|-----|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|NS|  a|b|a|b|b|a|  a|b|a|b  |b    |a|b|a|a| | | | | | | | | | |
|NT|**a|b|a|b|b|a|  a|b|a|b**|~~a~~|b|b|a|a| | | | | | | | | | |
|MS|  >| | | | | |  a|b|a|b  |b    |a|a|b|a|b|b|a|b|a|a| | | | |
|MT|   | | | | | |**a|b|a|b**|a    |b|b|a|a|b|a|b|b|a|b|a|a| | |
原理，我們都檢查過0~9了，那我們何必在檢查一次呢？  
原本我們把S放在0的位置，現在我們把它放在i-f[i]  
問題又來了,f[]要怎麼求，f[i]又代表什麼意思  
f[i]表示成功配對A[0:i]之後，在i+1配對失敗  
我們將A[F[i]]對齊原本A[i]的位置  
很抽象沒錯，看圖  
|  |0|1|2|3|4|5|6|7|8|9|
|--|-|-|-|-|-|-|-|-|-|-|
|  |a|b|a|b|c| | | | | |
|OA|a|b|a|b|X| | | | | |
| F| | | |2| | | | | | |
|  |>| |a|b|a|b|c| | | |
|AA| | |a|b| | | | | | |
而我們稱f[]的算法為Failure Function  
f[i]\<i  
(如果=i的話就沒意義了)  
其中f[i]滿足  
A[0:f[i]]=A[i-K:i]的最大值  
又是圖  
| |0|1|2  |3  |4|5|6|
|-|-|-|---|---|-|-|-|
|S|a|b|**a|b**|c| | |
| | | |**a|b**|a|b|c|
則i=3時，f[i]=1

若不存在f[i]，則設為-1
我們還能發現設成-1時，S字串會自己跑到i後面  
範例(虛擬碼):  
```c++
int KMP_match[](str s,int f[],str t){
    int re[];
    int p=-1;//表s的開頭在t的哪裡
    for(int i=0;i<t.size();i++){
	while(p!=-1 && s[p+1]!=t[i]){//如果字元不符，且s還在目前的搜尋範圍內
	    p=f[p];
	}
	if(s[p+1]==t[i]){//字元相符合，可以繼續搜索
		p++;
	}
	if(!s[p+1]){//如果接下來就到底了，get ans(字串的尾端是0)
	    ans.push_back(i-p);
	    p=f[p];//將s往前移
	}
    }
    return ans;
}
```
那要怎麼求f呢？

