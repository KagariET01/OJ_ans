# KMP
給兩字串S,T(|S|<=|T|<=5e5)  
試問S在T中哪些位置出現  
爆搜？O(|S|\*|T|)  
顯然不可能
那我們能不能把已經跑過的地方,用特殊方式存起來  
答案是肯定  
先給例子  
S=ababb aabab babaa  
T=ababb aabab abbaa babba baa  
|  |0  |1|2|3|4|5|6  |7|8|9  |.    |1|2|3|4|5|6|7|8|9|.|1|2|3|4|
|--|---|-|-|-|-|-|---|-|-|---|-----|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|NS|  a|b|a|b|b|a|  a|b|a|b  |b    |a|b|a|a| | | | | | | | | | |
|NT|**a|b|a|b|b|a|  a|b|a|b**|~~a~~|b|b|a|a| | | | | | | | | | |
|MS|  >| | | | | |  a|b|a|b  |b    |a|a|b|a|b|b|a|b|a|a| | | | |
|MT|   | | | | | |**a|b|a|b**|a    |b|b|a|a|b|a|b|b|a|b|a|a| | |
  
原理，我們都檢查過0~9了，那我們何必在檢查一次呢？  
原本我們把S放在0的位置，現在我們把它放在i-f[i]  
問題又來了,f[]要怎麼求，f[i]又代表什麼意思  
f[i]表示成功配對A[0:i]之後，在i+1配對失敗  
我們將A[F[i]]對齊原本A[i]的位置  
很抽象沒錯，看圖  
|  |0|1|2|3|4|5|6|7|8|9|
|--|-|-|-|-|-|-|-|-|-|-|
|  |a|b|a|b|c| | | | | |
|OA|a|b|a|b|X| | | | | |
| F| | | |2| | | | | | |
|  |>| |a|b|a|b|c| | | |
|AA| | |a|b| | | | | | |
  
而我們稱f[]的算法為Failure Function  
f[i]\<i  
(如果=i的話就沒意義了)  
其中f[i]滿足  
A[0:f[i]]=A[i-K:i]的最大值  
又是圖  
| |0|1|2  |3  |4|5|6|
|-|-|-|---|---|-|-|-|
|S|a|b|**a|b**|c| | |
| | | |**a|b**|a|b|c|
  
則i=3時，f[i]=1

若不存在f[i]，則設為-1
我們還能發現設成-1時，S字串會自己跑到i後面  
範例(虛擬碼):  
```c++
int KMP_match[](str s,int f[],str t){
    int re[];
    int p=-1;//表s的開頭在t的哪裡
    for(int i=0;i<t.size();i++){
	while(p!=-1 && s[p+1]!=t[i]){//如果字元不符，且s還在目前的搜尋範圍內
	    p=f[p];
	}
	if(s[p+1]==t[i]){//字元相符合，可以繼續搜索
		p++;
	}
	if(!s[p+1]){//如果接下來就到底了，get ans(字串的尾端是0)
	    ans.push_back(i-p);
	    p=f[p];//將s往前移
	}
    }
    return ans;
}
```
那要怎麼求f呢？  
我們來看一個例子：  
| |0|1|2|3|4|5|6|7|8|9|.|1|2|3|4|  
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|  
|S|a|b|a|b|b|a|a|b|a|b|b|a|b|a|a|  
|F|.|.|0|1|.|0|0|1|2|3|4|5|1|2|0|  
  
我們可以發現F[i]+1>=f[i+1]  
證明如下  
  
> 令F[i+1]=x(i>=0)  
> if x==0 || x==-1
> > 原式成立\
> > F[i]+1>=-1,0\
> > F[i]>=-2,-1
> >
> else  
> > A[0:x]=A[i+1-x:i+1]  
> > > A[0:x-1]=A[i-(x-1):i]\
> > > F[i]>=x-1\
> > > F[i]>=F[i+1]-1\
> > > F[i+1]\<=F[i]+1
這個特性很重要，要記得  
  
## 求f  
> if F[i]=x x!=-1 (上一個值有效)
> > A[0:x]=A[i-x:i]\
> > if(A[x+1]==A[i+1]) (下一個字元也符合現況)
> > > A[0:x+1]=A[(i+1)-(x+1):i+1]\
> > > F[i+1]=x+1
> > >
> > else if(A[x+1]!=A[i+1])
> > > 找下一個K(\<x)使得A[0:K]==A[i-K:i]\
> > > A[0:K]=A[i-K:i]=A[x-K:x]\
> > > ***F[X]***\
> > > > 又是原理圖
> > > > |    |0|1|2|3|4|5|6|7|8|9|.| |
> > > > |----|-|-|-|-|-|-|-|-|-|-|-|-|
> > > > |   T|A|B|A|B|B|A|B|A|B|B|D| |
> > > > |nowS| | | | | |A|B|A|B|B| |我們能發現這字串和S的前綴一樣，那我們就可以直接拿它取F值|
> > > > |nxtS| | | | | | | |A|B|A|B|S移動過後的結果|
> > > >  
> > > > 那麼我們要把S往右邊移，是不是只要移F[x]就行了？\
> > > > 對，沒錯\
> > > > (其實上面那個例子沒有舉的很好，但你們先體會一下)
> > > >
> else(上一個值無效)
> > 如果上個值無效，那就簡單了\
> > (如果現在的值和地一個值相同，代表link，反之，則link fail)
> > if(A[i]==A[0]) F[i]=0
> > else F[i]=-1

[code](kmp.cpp)
